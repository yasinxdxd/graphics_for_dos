#include "GFDDEF.H"
#include "GFDUTILS.H"

/* declarations of our all functions */

int dec_gfdInit()
{
    asm volatile(
    "mov $0x13, %al\n"       //graphical mode, 40x25, 256 colors.
    "mov $0x0, %ah\n"
    "int $0x10\n"           //apply configuration.
    );

    return 0;
}

void dec_gfdDestroy()
{
    asm volatile(
    "mov $0x03, %al\n"
    "int $0x21\n"
    );
}

void dec_gfdDrawPixel(unsigned int x, unsigned int y)
{
    asm volatile(
    "mov $0b1100, %%al\n"     //temporary, pixel color(light red)
    "mov $0x0C, %%ah\n"       //temporary, to set the color.
    "mov %0, %%cx\n"           //x pos
    "mov $0, %%dx\n"         //y pos
    "int $0x10\n"           //draw pixel
    :"=r"(x)
    );

}

//"mov ah, 0x0C\n"       //change the color --> for color function.

void dec_gfdDrawLine(unsigned int x0, unsigned int y0, unsigned int x1, unsigned int y1)
{
    //DDA line algorithm
    int delta_x = x0 - x1;
    int delta_y = y0 - y1;
    unsigned int steps = (unsigned int)imax(delta_x, delta_y);  //we need to get max delta value to avoid gaps between pixels.
    float m = delta_y / delta_x;    //tanjant of our line.

    float index_x, index_y;

    int pixel_x = x0, pixel_y = y0;

    if(m > 1)   // if tetha angle greater than 45 degree
    {
        index_y = 1;
        index_x = 1 / m;
        
        while(pixel_y != y1)
        {
            pixel_x += index_x;
            pixel_y += index_y;
        }
    }
    else        // if tetha angle less than 45 degree
    {
        index_y = m;
        index_x = 1;

        while(pixel_x != x1)
        {
            pixel_x += index_x;
            pixel_y += index_y;
        }
    }

    

    // if angle equals 45 degree no matter which case it is in.

}
